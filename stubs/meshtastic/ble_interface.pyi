import io
import types
from .protobuf import mesh_pb2 as mesh_pb2
from _typeshed import Incomplete
from bleak import BLEDevice as BLEDevice
from meshtastic.mesh_interface import MeshInterface as MeshInterface

SERVICE_UUID: str
TORADIO_UUID: str
FROMRADIO_UUID: str
FROMNUM_UUID: str
LEGACY_LOGRADIO_UUID: str
LOGRADIO_UUID: str

class BLEInterface(MeshInterface):
    class BLEError(Exception): ...
    should_read: bool
    client: BLEClient | None
    def __init__(self, address: str | None, noProto: bool = False, debugOut: io.TextIOWrapper | None = None, noNodes: bool = False) -> None: ...
    def from_num_handler(self, _, b: bytes) -> None: ...
    async def log_radio_handler(self, _, b) -> None: ...
    async def legacy_log_radio_handler(self, _, b) -> None: ...
    @staticmethod
    def scan() -> list[BLEDevice]: ...
    def find_device(self, address: str | None) -> BLEDevice: ...
    def connect(self, address: str | None = None) -> BLEClient: ...
    def close(self) -> None: ...

class BLEClient:
    bleak_client: Incomplete
    def __init__(self, address=None, **kwargs) -> None: ...
    def discover(self, **kwargs): ...
    def pair(self, **kwargs): ...
    def connect(self, **kwargs): ...
    def disconnect(self, **kwargs) -> None: ...
    def read_gatt_char(self, *args, **kwargs): ...
    def write_gatt_char(self, *args, **kwargs) -> None: ...
    def has_characteristic(self, specifier): ...
    def start_notify(self, *args, **kwargs) -> None: ...
    def close(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, _type: type[BaseException] | None, _value: BaseException | None, _traceback: types.TracebackType | None) -> None: ...
    def async_await(self, coro, timeout=None): ...
    def async_run(self, coro): ...
