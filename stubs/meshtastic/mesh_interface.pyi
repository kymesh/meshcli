import collections
import meshtastic.node
import threading
import types
from _typeshed import Incomplete
from meshtastic import BROADCAST_ADDR as BROADCAST_ADDR, BROADCAST_NUM as BROADCAST_NUM, LOCAL_ADDR as LOCAL_ADDR, NODELESS_WANT_CONFIG_ID as NODELESS_WANT_CONFIG_ID, ResponseHandler as ResponseHandler, protocols as protocols, publishingThread as publishingThread
from meshtastic.protobuf import mesh_pb2 as mesh_pb2, portnums_pb2 as portnums_pb2, telemetry_pb2 as telemetry_pb2
from meshtastic.util import Acknowledgment as Acknowledgment, Timeout as Timeout, convert_mac_addr as convert_mac_addr, message_to_json as message_to_json, our_exit as our_exit, remove_keys_from_dict as remove_keys_from_dict, stripnl as stripnl
from typing import Any, Callable

class MeshInterface:
    class MeshInterfaceError(Exception):
        message: Incomplete
        def __init__(self, message) -> None: ...
    debugOut: Incomplete
    nodes: dict[str, dict] | None
    isConnected: threading.Event
    noProto: bool
    localNode: meshtastic.node.Node
    myInfo: mesh_pb2.MyNodeInfo | None
    metadata: mesh_pb2.DeviceMetadata | None
    responseHandlers: dict[int, ResponseHandler]
    failure: Incomplete
    heartbeatTimer: threading.Timer | None
    currentPacketId: int
    nodesByNum: dict[int, dict] | None
    noNodes: bool
    configId: int | None
    gotResponse: bool
    mask: int | None
    queueStatus: mesh_pb2.QueueStatus | None
    queue: collections.OrderedDict
    def __init__(self, debugOut=None, noProto: bool = False, noNodes: bool = False) -> None: ...
    def close(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, trace: types.TracebackType | None) -> None: ...
    def showInfo(self, file=...) -> str: ...
    def showNodes(self, includeSelf: bool = True, showFields: list[str] | None = None) -> str: ...
    def getNode(self, nodeId: str, requestChannels: bool = True, requestChannelAttempts: int = 3, timeout: int = 300) -> meshtastic.node.Node: ...
    def sendText(self, text: str, destinationId: int | str = ..., wantAck: bool = False, wantResponse: bool = False, onResponse: Callable[[dict], Any] | None = None, channelIndex: int = 0, portNum: portnums_pb2.PortNum.ValueType = ...): ...
    def sendAlert(self, text: str, destinationId: int | str = ..., onResponse: Callable[[dict], Any] | None = None, channelIndex: int = 0): ...
    def sendData(self, data, destinationId: int | str = ..., portNum: portnums_pb2.PortNum.ValueType = ..., wantAck: bool = False, wantResponse: bool = False, onResponse: Callable[[dict], Any] | None = None, onResponseAckPermitted: bool = False, channelIndex: int = 0, hopLimit: int | None = None, pkiEncrypted: bool | None = False, publicKey: bytes | None = None, priority: mesh_pb2.MeshPacket.Priority.ValueType = ...): ...
    def sendPosition(self, latitude: float = 0.0, longitude: float = 0.0, altitude: int = 0, destinationId: int | str = ..., wantAck: bool = False, wantResponse: bool = False, channelIndex: int = 0): ...
    def onResponsePosition(self, p) -> None: ...
    def sendTraceRoute(self, dest: int | str, hopLimit: int, channelIndex: int = 0): ...
    def onResponseTraceRoute(self, p: dict): ...
    def sendTelemetry(self, destinationId: int | str = ..., wantResponse: bool = False, channelIndex: int = 0, telemetryType: str = 'device_metrics'): ...
    def onResponseTelemetry(self, p: dict): ...
    def onResponseWaypoint(self, p: dict): ...
    def sendWaypoint(self, name, description, expire: int, waypoint_id: int | None = None, latitude: float = 0.0, longitude: float = 0.0, destinationId: int | str = ..., wantAck: bool = True, wantResponse: bool = False, channelIndex: int = 0): ...
    def deleteWaypoint(self, waypoint_id: int, destinationId: int | str = ..., wantAck: bool = True, wantResponse: bool = False, channelIndex: int = 0): ...
    def waitForConfig(self) -> None: ...
    def waitForAckNak(self) -> None: ...
    def waitForTraceRoute(self, waitFactor) -> None: ...
    def waitForTelemetry(self) -> None: ...
    def waitForPosition(self) -> None: ...
    def waitForWaypoint(self) -> None: ...
    def getMyNodeInfo(self) -> dict | None: ...
    def getMyUser(self): ...
    def getLongName(self): ...
    def getShortName(self): ...
    def getPublicKey(self): ...
    def sendHeartbeat(self) -> None: ...
